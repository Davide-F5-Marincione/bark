\documentclass[a4paper, 10pt]{scrartcl}

\usepackage{microtype}
\usepackage[scale=.8]{geometry}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{hyperref}

\newcommand{\noderepr}[1]{\textsf{\textbf{#1}}}
\newcommand{\edgerepr}[1]{\textit{\textbf{#1}}}

\newcommand{\squarenode}{\noderepr{square}}
\newcommand{\slidegroupnode}{\noderepr{slide\_group}}
\newcommand{\bishopgroupnode}{\noderepr{bishop\_like\_group}}
\newcommand{\rookgroupnode}{\noderepr{rook\_like\_group}}
\newcommand{\piece}{\noderepr{piece}}
\newcommand{\pawn}{\noderepr{pawn}}
\newcommand{\knight}{\noderepr{knight}}
\newcommand{\bishoplike}{\noderepr{bishoplike}}
\newcommand{\rooklike}{\noderepr{rooklike}}
\newcommand{\bishop}{\noderepr{bishop}}
\newcommand{\rook}{\noderepr{rook}}
\newcommand{\queen}{\noderepr{queen}}
\newcommand{\king}{\noderepr{king}}
\newcommand{\gamestate}{\noderepr{game\_state}}
\newcommand{\guard}{\noderepr{guard}}
\newcommand{\push}{\noderepr{push}}
\newcommand{\pop}{\noderepr{pop}}
\newcommand{\threatcheck}{\noderepr{threat\_check}}
\newcommand{\gameinfo}{\noderepr{game\_info}}
\newcommand{\void}{\noderepr{void\_guard}}
\newcommand{\stackend}{\noderepr{stack\_end}}
\newcommand{\produce}{\noderepr{produce}}
\newcommand{\hproduce}{\noderepr{hproduce}}
\newcommand{\evaluate}{\noderepr{evaluate}}
\newcommand{\tellmewhy}{\noderepr{end\_game\_check}} % I don't know why latex doesn't let me use "endgame" as a command name
\newcommand{\ai}{\noderepr{nega\_alpha\_beta}}
\newcommand{\airesult}{\noderepr{ai\_result}}
\newcommand{\select}{\noderepr{select}}

\newcommand{\adj}{\edgerepr{adj}}
\newcommand{\partof}{\edgerepr{part\_of}}
\newcommand{\at}{\edgerepr{at}}
\newcommand{\stateptr}{\edgerepr{state\_ptr}}
\newcommand{\nextguard}{\edgerepr{next\_guard}}
\newcommand{\nextstate}{\edgerepr{next\_state}}
\newcommand{\mover}{\edgerepr{mover}}
\newcommand{\tosquare}{\edgerepr{to}}
\newcommand{\fromsquare}{\edgerepr{from}}
\newcommand{\threattgt}{\edgerepr{threat\_tgt}}
\newcommand{\illegal}{\edgerepr{illegal}}
\newcommand{\promotioninto}{\edgerepr{promotion\_into}}
\newcommand{\edgeselect}{\edgerepr{select}}
\newcommand{\paststate}{\edgerepr{past\_state}}

\title{Bark: An Attributed Graph Grammar Chess Engine}
\author{Davide Marincione\\\small\texttt{marincione.1927757@studenti.uniroma1.it}}

\begin{document}
    \maketitle
    \section{Introduction}
    Chess is a fairly complex game, with a relatively wide set of rules and a small but non-trivial branching factor (unlike Go, which has very simple rules but huge branching factor). This makes it a good candidate for projects such as Bark. Unlike traditional chess engines, Bark is not programmed in any language: it is instead a set of rules that can be applied to a graph, which is then used to play chess. This makes it a very complex and unwieldy project, as it requires a lot of work to define the rules and the graph structure. In this report, we will describe the rules and the graph structure used in Bark, how their mechanisms differ from a usual chess engine, and we will discuss the challenges and limitations of the project.

    \paragraph{Two small disclaimers} Since this report is dealing with attributed graph grammars, it is full of words like "node" and "edge"; to avoid repetition, we will use the formatting \noderepr{node} and \edgerepr{edge} to decrease the verbosity. Furthermore, in the AGG software, to correctly run the project, layered graph transformation must be enabled, and the removal of "dangling" edges must be allowed.

    \section{Representing the board}
    Chess cannot be played without a chessboard, therefore the first step in creating Bark was to define a graph structure that could represent the board.
    \paragraph{How it is done} Fortuitously, a chessboard is composed of 64 squares and, because of that, it can be conveniently be represented as a set of 64-bit integers, where each bit gives the value of a square with respect to specific information of the board. Because of this, a chessboard is usually represented with twelve 64-bit integers, one for each piece type and color. Not only is this representation very compact, but it also allows for very fast operations, as bitwise "magic bitboard" operations are at the core of every modern chess engine.
    \paragraph{Bark's nodes} Bark, however, does not use this representation. Instead, the board is composed of 64 \squarenode\ and 46 \slidegroupnode\  nodes. Each \squarenode\ is connected to its neighbors via a \adj\ and to its \slidegroupnode s via a \partof. Neighbors are defined only to be those \squarenode s with a common edge, and \slidegroupnode s are used to represent the groups of squares reachable in a single move by sliding pieces (bishop, rook or queen). Because of this, \slidegroupnode\ is actually an abstract class from which \bishopgroupnode\ and \rookgroupnode\ inherit.
    For ease of view and without real impact to the system: \squarenode\ is actually an abstract class which is inherited by \noderepr{white\_square} and \noderepr{black\_square}, \bishopgroupnode\ too is abstract, inherited by \noderepr{left\_group} and \noderepr{right\_group}, and \rookgroupnode\ is inherited by \noderepr{ver\_group} and \noderepr{hor\_group}.
    Finally, each \squarenode\ has a \texttt{file} and \texttt{rank} attribute, which are used to represent the position of the square on the board.
    \begin{figure}[H]
        \centering
        \includegraphics[width=.8\linewidth]{images/type_graph.png}
        \caption{The type graph of the system.}
    \end{figure}

    \paragraph{Construction by rules} We could have set up the board by hand (as we actually do to position the pieces and starting the game), but that would have been quite tedious because of the multiple edges needed to make it complete. Instead, we use a set of rules to produce it, which are as follows:
    \begin{enumerate}
        \item \texttt{produce\_first\_square} creates a first square of the board (the white top left square, \texttt{file=0} and \texttt{rank=7}), if it has not been created yet. This is then used as a seed for the rest of the construction.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/produce_first_square.png}
            \caption{\texttt{produce\_first\_square}}
        \end{figure}

        \item \texttt{produce\_top\_rank\_b/w} respectively create black and white squares of the top rank, if the they have not been created yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/produce_top_rank.png}
            \caption{\texttt{produce\_top\_rank}}
        \end{figure}

        \item \texttt{produce\_first\_file\_b/w} respectively create the black and white squares of the first file, if they have not been created yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/produce_first_file.png}
            \caption{\texttt{produce\_first\_file}}
        \end{figure}
    \end{enumerate}
    These first rules create the top rank and the left file of the board. The rest of the board is then created by applying:
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item \texttt{produce\_square\_b/w} creates a black or white square, if it has not been created yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/produce_square.png}
            \caption{\texttt{produce\_square}}
        \end{figure}

        \item \texttt{add\_right\_group} adds a \noderepr{right\_group} to squares on the last file, if it has not been added yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/add_right_group.png}
            \caption{\texttt{add\_right\_group}}
        \end{figure}

        \item \texttt{produce\_right\_group} connects top-right to bottom-left the squares to the same group, if it has not been done yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/produce_right_group.png}
            \caption{\texttt{produce\_right\_group}}
        \end{figure}
    \end{enumerate}
    These rules are then applied in a loop until the board is complete.
    Of course, this is just a \emph{topological} description of the board, and, indeed, applying these rules doesn't result in a good-looking graph.
    \begin{figure}[H]
        \centering
        \includegraphics[width=.5\linewidth]{images/messy_board.png}
        \caption{The board after applying the rules.}
    \end{figure}
    To make it comprehensible, we order it by hand.
    \begin{figure}[H]
        \centering
        \includegraphics[width=.8\linewidth]{images/board.png}
        \caption{The board after hand-made ordering.}
    \end{figure}

    \section{Representing game states and enabling complex behaviors}
    Pieces are represented as nodes connected (via an \at) to the squares they are on. With a boolean \texttt{color} attribute (\texttt{false} for black pieces and \texttt{true} for white ones), \piece\ is the parent class, which is inherited by the \pawn, \knight, \bishoplike, \rooklike, and \king\ nodes. Specifically, the \bishoplike\ and \rooklike\ nodes are further inherited by \bishop, \rook, and \queen\ nodes, the latter of which is the only example of multiple inheritance in the system (as it moves like a rook and a bishop).
    A game state is not only composed by the pieces' positions on the board, but also by the information about the current rights to move, the castling rights, the last move, and the move counter (ply). This information is stored, explicitly via attributes and implicitly via edges, in the \gamestate.

    \paragraph*{Not only structure} Until now, we've only focused on defining a representation for the game, without including a description for its behavior. Graph rewriting mechanisms by themselves are enough to define a description for the rules of a game such as chess. But, to simplify the design of complex algorithms, we define another set of nodes all inheriting from \guard. These compose a stack (through the use of \nextguard) of operations which are used to enable only a subset of the rules at a time. Thanks to these, we were able to define the generation of moves, the evaluation of the board, the exploration of the game tree, and more.
    \begin{figure}[H]
        \centering
        \includegraphics[width=.8\linewidth]{images/base_state.png}
        \caption{The starting configuration of the board.}
    \end{figure}
    Out of these \guard\ nodes, there are three that are designed for the control of the stack itself:
    \begin{enumerate}
        \item \gameinfo\ acts both as the start of the stack and as a container for the game information (which player is human and the depth of the search).
        \item \void\ has a usage akin to a "no-op" operation, as it is used to block all rules until it is removed.
        \item \stackend\ is the end of the stack, and it is used to signal which guard is at the top of the stack.
    \end{enumerate}
    All guards can have a \stateptr\ which connects them to a \gamestate.

    \section{Generating moves}
    \paragraph*{How it is done} As cited previously, in a traditional chess engine a lot of computations are done via "magic bitboards". These are perfect hashing algorithms which can trivialize a lot of checks, even the generation of movements. Without getting into the details, the moves are produced in a two-phase manner:
    \begin{enumerate}
        \item The result of every possible move is generated (via magic bitboards), without any forward checking (e.g. leaving the king in check), as that is usually too complex and slow to implement. The resulting set is called "pseudo-legal moves".
        \item For every possible resulting board, the king is checked for being in check. If it is, the move is discarded. This filtered set is called "legal moves".
    \end{enumerate}
    A further information to keep into account is that a chess engine usually enables "push" and "pop" operation on moves (i.e. to make a move and then undo it). This is done by keeping a stack of the boards, and pushing a new configuration every time a move is made. This is a very efficient way to implement the "undo" functionality, as it doesn't require to recompute the whole board every time. Furthermore, it is also used to implement the exploration of the game tree, as it allows backtracking to the previous state of the game.
    \paragraph*{How Bark does it} Bark, of course, cannot use magic bitboards. To produce a move, we have the \produce\ guard, which is "checked" upon by all the \texttt{move\_*} and \texttt{capture\_*} rules.
    Our method to generate moves is akin to the traditional one, but since we can afford to hold only a single board instance, it is more complex (and slow). We represent the game tree by connecting the \gamestate\ nodes: when pushing and popping the moves, instead of retrieving a stored configuration, we use the information present on the \gamestate\ to execute or revert the move by operating on the board instance.
    To implement push, pop and threat check operations we design multiple rules and their respective guards (\push, \pop, and \threatcheck), which we'll describe in further sections.

    To avoid repetitions, we first describe the patterns common to most (if not all) the \texttt{move\_*} and \texttt{capture\_*} rules:
    \begin{itemize}
        \item All rules produce a new \gamestate\ node, which is connected to the current one via a \nextstate\ edge. The moved piece gets a \mover\ connecting it to the new state, and the new state gets connected to the arriving square through a \tosquare\ edge. All but a couple rules append \pop, \threatcheck, and \push\ (which we define in the next section) to the stack.
        For the sake of the \threatcheck, moves will require the king of the moving color, to pass its position to \threatcheck.
        \item All rules have a NAC \texttt{already\_added} to ensure that the rule has not been applied yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.5\linewidth]{images/already_added_move.png}
            \caption{The \texttt{already\_added} NAC of the \texttt{move\_knight} rule.}
        \end{figure}
    \end{itemize}
    The rules are:
    \begin{enumerate}
        \item \texttt{move\_pawn} applies only when the next square is empty (\texttt{no\_blocker} NAC) and the pawn is moving forward (\texttt{r2==r1+(c?1:-1)}). It also checks that the move will not lead to a promotion (\texttt{r1!=(c?6:1)}), as it is handled by another rule.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_pawn.png}
            \caption{\texttt{move\_pawn}}
        \end{figure}
        \item \texttt{move\_pawn\_promotion\_white/black} apply like the \texttt{move\_pawn} rule, but only when the move leads to a promotion (i.e. the rank reached is either 7 or 0, based on moving color). These are among the only rules that don't append \pop, \threatcheck, and \push\ to the stack, but make a more complex update to it (as each possible promotion is a different move). Furthermore, each \gamestate\ is connected to the promotion piece via a \promotioninto edge.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_pawn_promotion_white.png}
            \caption{\texttt{move\_pawn\_promotion\_white}}
        \end{figure}
        \item \texttt{move\_pawn\_double} applies only when both next squares are empty (\texttt{no\_blocker} and \texttt{no\_middle\_blocker} NAC) and the pawn is moving forward (\texttt{r2==r1+(c?2:-2)}). It also checks that this is done only when it is the first move of the piece (\texttt{r1==(c?1:6)}).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_pawn_double.png}
            \caption{\texttt{move\_pawn\_double}}
        \end{figure}
        \item \texttt{capture\_pawn} applies only when the next square contains a foe or an en passant is possible (\texttt{normal\_capture | en\_passant} GAC) and the pawn is moving forward (\texttt{r2==r1+(c?1:-1)}). It also checks that the move will not lead to a promotion (\texttt{r1!=(c?6:1)}), as it is handled by another rule.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/capture_pawn.png}
            \caption{\texttt{capture\_pawn}}
        \end{figure}
        \item \texttt{capture\_pawn\_promotion\_white/black} apply like the \texttt{capture\_pawn} rule, but only when the move leads to a promotion (i.e. the rank reached is either 7 or 0, based on moving color). Again, these are among the only rules that make a more complex update to the stack (as each possible promotion is a different move). Unlike the normal \texttt{capture\_pawn} rule, there is no need to check for en passant, as it is impossible when a promotion is happening. Again, each \gamestate\ is connected to the promotion piece via a \promotioninto edge.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/capture_pawn_promotion_white.png}
            \caption{\texttt{capture\_pawn\_promotion\_white}}
        \end{figure}
        \item \texttt{move\_knight} applies both to normal moves and captures (indeed, there doesn't exist a \texttt{capture\_knight}). To ensure that the piece can only move to an empty square or over a foe, a \texttt{no\_blocker} NAC is added.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_knight.png}
            \caption{\texttt{move\_knight}}
        \end{figure}
        \item \texttt{move\_bishop\_like} applies both to normal moves and captures, to both bishops and queens. To ensure that the piece can only move to an empty square or over a foe, a \texttt{no\_blocker} NAC is added. Furthermore, to ensure that there is no piece in between the starting and arriving squares, a \texttt{no\_middle\_blocker} NAC is added; this is possible only when the piece is in the same \bishopgroupnode, and it abides
        \begin{equation}\label{eq:slidegroupcheck}
            (8(f_3-f_1)+r_3-r_1)(8(f_3-f_2)+r_3-r_2)<0
        \end{equation}
        which is the condition for the middle ($f_3, r_3$) square to be between the starting ($f_1, r_1$) and arriving ($f_2, r_2$) squares.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_bishop_like.png}
            \caption{\texttt{move\_bishop\_like}}
        \end{figure}
        \item \texttt{move\_rook} applies both to normal moves and captures, but only to rooks (as these have to disable castling when it is the first time they move, queens do not). It works similarly to the \texttt{move\_bishop\_like} rule, with the only difference that the common slide group must be a \rookgroupnode. Again, the possible middle blocker at square ($f_3, r_3$) must abide \ref{eq:slidegroupcheck}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_rook.png}
            \caption{\texttt{move\_rook}}
        \end{figure}
        \item \texttt{move\_queen} acts equivalently to \texttt{move\_rook}, with the only exception that it doesn't disable castling.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_queen.png}
            \caption{\texttt{move\_queen}}
        \end{figure}
        \item \texttt{move\_king\_adj} applies both to normal moves and captures. To ensure that the piece can only move to an empty square or over a foe, a \texttt{no\_blocker} NAC is added. Of course, as it is the king itself that is moving, the \threatcheck\ checks on the arriving square, also, as the king is moving, the castling rights are updated.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_king_adj.png}
            \caption{\texttt{move\_king\_adj}}
        \end{figure}
        \item \texttt{move\_king\_diag} acts the same as \texttt{move\_king\_adj}, the only difference is in the diagonal moves.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_king_diag.png}
            \caption{\texttt{move\_king\_diag}}
        \end{figure}
        \item \texttt{move\_kingside/queenside\_castle} execute castling (if it is enabled in the current \gamestate, \texttt{c?Kcastle:kcastle} and \texttt{c?Qcastle:qcastle}). They also check that the squares between the king and the rook are empty (\texttt{no\_blocker*} NACs). As castling can only be done when the king is not in check (or moving across checked squares), these are the only moves that append \threatcheck\ to the stack before \push. Of course the resulting game state has the castling rights updated.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/move_kingside_castle.png}
            \caption{\texttt{move\_kingside\_castle}}
        \end{figure}
    \end{enumerate}
    \section{Threat check, push, and pop}
    As mentioned, to discern between a legal move and a non-legal one, but also to enable exploration, we devised three guards: \push, \pop, and \threatcheck.
    Along with these guards, we have multiple rules accompanying them, which we describe.
    \paragraph*{Threat check} All the \texttt{move\_*} and \texttt{capture\_*} rules append one or multiple \threatcheck s to the stack. A single instance of this guard is used to check if a square, connected via the \threattgt\ edge, is under threat by a given color, defined by the \texttt{attacker} attribute. This check is only used to discard moves that would leave the king in check or otherwise make the rule illegal, therefore we don't model it for cases such as en passant (for which the king can't be affected).
    If any rule applies, the \gamestate\ is flagged via the \illegal\ edge; but we do not remove it from the graph immediately, as it is needed to book-keep which pseudo-legal moves have been checked.
    To do this, we have the following rules:
    \begin{enumerate}
        \item \texttt{threat\_pawn} applies if \texttt{r2==r1+(c?1:-1)}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/threat_pawn.png}
            \caption{\texttt{threat\_pawn}}
        \end{figure}
        \item \texttt{threat\_knight} is one of the simplest rules, it doesn't have any NACs!
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/threat_knight.png}
            \caption{\texttt{threat\_knight}}
        \end{figure}
        \item \texttt{threat\_bishop/rook\_like} are equal rules, with the only exception that one checks for attacks on diagonals and the other on vertical/horizontal lines. Both check the presence of a possible middle blocker via the \texttt{no\_blockers} rule, which again follow \ref{eq:slidegroupcheck}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/threat_bishop_like.png}
            \caption{\texttt{threat\_bishop\_like}}
        \end{figure}
        \item \texttt{threat\_king} applies for attacks from a king both from adjacent squares and diagonals, using a GAC which checks \texttt{(adj | diag)}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/threat_king.png}
            \caption{\texttt{threat\_king}}
        \end{figure}
    \end{enumerate}

    \paragraph*{Push} All the \texttt{push\_*} rules have the common behavior of adding, to the pushed \gamestate, a \fromsquare\ edge pointing to the square the moving piece is coming from. This is used to enable the \texttt{pop\_*} rules to revert the move. The rules are:
    \begin{enumerate}
        \item \texttt{push\_move} is the most generic of moves, and indeed it is the most "restricted" of the bunch, as it may apply to the result of any \texttt{move\_*} or \texttt{capture\_*} rule. To restrict it, we have \texttt{is\_capture}, \texttt{is\_promotion}, \texttt{is\_en\_passant} and \texttt{is\_castling} NACs. We have to devise a specific \texttt{is\_en\_passant} NAC as all other captures can easily be checked by whether there is an enemy piece on the arriving square, but en passant requires the presence of a foe pawn on the same file as the moving pawn.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/push_move.png}
            \caption{\texttt{push\_move}}
        \end{figure}
        \item \texttt{push\_capture} applies whenever the \gamestate\ points the \tosquare\ edge to a square with an enemy piece. Its only NAC is \texttt{is\_promotion}, as there is a specific rule for that.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/push_capture.png}
            \caption{\texttt{push\_capture}}
        \end{figure}
        \item \texttt{push\_en\_passant} applies to a very specific pattern, as it is the only capture that doesn't require the presence of an enemy piece on the arriving square.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/push_en_passant.png}
            \caption{\texttt{push\_en\_passant}}
        \end{figure}
        \item \texttt{push\_castling} too is very specific, it is the only move where the king moves two squares and two pieces are moved at once. It also has to abide \texttt{f3==2?f2==3\&\&f1==0:f2==5\&\&f1==7}, which checks that the rook is in the right position.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/push_castling.png}
            \caption{\texttt{push\_castling}}
        \end{figure}
        \item \texttt{push\_promotion} applies only when the \gamestate\ points to a promotion piece via the \promotioninto\ edge. In this case we need a NAC to make sure that the rule is not a capture, as there is a specific rule for that.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/push_promotion.png}
            \caption{\texttt{push\_promotion}}
        \end{figure}
        \item \texttt{push\_promotion\_cap} works in much the same way of \texttt{push\_promotion}, with the only difference that it is a capture.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/push_promotion_cap.png}
            \caption{\texttt{push\_promotion\_cap}}
        \end{figure} 
    \end{enumerate}

    \paragraph*{Pop} As one might assume, the \texttt{pop\_*} rules are the inverse of the \texttt{push\_*} rules, and can be found to be quite similar to their counterparts. Thanks to the \fromsquare\ edges, these can be executed. They are:
    \begin{enumerate}
        \item \texttt{pop\_move} it has \texttt{is\_capture} and \texttt{is\_castling} NACs but, unlike its counterpart \texttt{push\_move}, it doesn't need to check for promotions, as a promoted rule doesn't have the \mover\ edge; nor does it need to check for en passant, as en passants are handled by \texttt{is\_capture} (in this case).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/pop_move.png}
            \caption{\texttt{pop\_move}}
        \end{figure}
        \item \texttt{pop\_capture} again, this doesn't have to check for promotions, as they don't have the \mover\ edge. But it has to check for en passants via the \texttt{is\_en\_passant} NAC, as, again, they are handled by another rule (as the captured piece cannot be put in the square pointed by \tosquare).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/pop_capture.png}
            \caption{\texttt{pop\_capture}}
        \end{figure}
        \item \texttt{pop\_en\_passant} like its counterpart, is quite specific (therefore the lack of NACs).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/pop_en_passant.png}
            \caption{\texttt{pop\_en\_passant}}
        \end{figure}
        \item \texttt{pop\_castling} too, like its counterpart, has to abide a rule to check that the rook is in the right position \texttt{f1==2?f2==3\&\&f3==0:f2==5\&\&f3==7}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/pop_castling.png}
            \caption{\texttt{pop\_castling}}
        \end{figure}
        \item \texttt{pop\_promotion} checks that the rule is not a capture, as it is handled by another rule (again).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/pop_promotion.png}
            \caption{\texttt{pop\_promotion}}
        \end{figure}
        \item \texttt{pop\_promotion\_cap} is the same as \texttt{pop\_promotion}, but for captures.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/pop_promotion_cap.png}
            \caption{\texttt{pop\_promotion\_cap}}
        \end{figure}
    \end{enumerate}

    \section{End game checks}
    Leaving aside a couple of rules (which we'll describe in the misc section), the modeling of the game is finalized with the end game checks. For simplicity, we don't check for the fifty-move rule, threefold repetition, or insufficient material, as these are quite complex to model and are not needed for the basic functioning of the game. We only check for checkmate and stalemate. To do so, we add the guard \tellmewhy\ and make it act with the following rules:

    \begin{enumerate}
        \item \texttt{select\_turn\_end\_game} checks that the current player cannot make any legal move anymore (\texttt{all\_illegal} GAC, which just checks that all produced moves are illegal), and that therefore the game must end, either in a draw or in a checkmate. To do that, we issue a threat check on the king.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/select_turn_end_game.png}
            \caption{\texttt{select\_turn\_end\_game}}
        \end{figure}
        \item \texttt{end\_game\_draw} if the current game state doesn't have the king under check (the state doesn't have an \illegal), ends the game in a draw.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_game_draw.png}
            \caption{\texttt{end\_game\_draw}}
        \end{figure}
        \item \texttt{end\_game\_checkmate} if the current game state has the king under check, ends the game in a checkmate.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_game_checkmate.png}
            \caption{\texttt{end\_game\_checkmate}}
        \end{figure}
    \end{enumerate}

    \section{The chess engine}
    \paragraph*{How it is done} Chess engines are usually built upon the minimax search algorithm; there exists multiple variations of it, which further improve the search, with a myriad of tricks. The most important of these is the alpha-beta pruning of course, which enables the engine discard a lot of branches of the search tree, which are not useful. Furthermore, most engines have some forward-pruning techniques, which enable them to discard (or, at least, give less priority) certain branches.
    \paragraph*{How Bark does it} We employ one of the most basic variations of minimax, the \href{https://www.chessprogramming.org/Alpha-Beta}{Nega-Alpha-Beta} algorithm, in its purest form (without any other elements). At the outset, we wanted to use the \href{https://www.chessprogramming.org/NegaScout}{NegaScout} algorithm, but in the end we found out that, if the order of the moves is not optimal (and we don't do move-ordering in Bark), it can be slower than the pure Nega-Alpha-Beta. The algorithm is implemented thanks to the \ai\ guard, which contains the depth at which the search is being done, and the alpha and beta values of the search. Furthermore, we add the \airesult\ guard to represent the result of a search call. These are used in the rules, which roughly represent the behavior of the algorithm:
    \begin{enumerate}
        \item \texttt{result\_store} stores, if a best game state has not been decided yet (for the current search), the result of the child search, and sets it as the best game state.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/result_store.png}
            \caption{\texttt{result\_store}}
        \end{figure}
        \item \texttt{result\_store\_exists\_best} if a best game state has been decided, compares the result of the child search with the best game state (the alpha), and sets the best game state to the best of the two.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/result_store_exists_best.png}
            \caption{\texttt{result\_store\_exists\_best}}
        \end{figure}
        \item \texttt{result\_bubble\_up} ends and returns the current search, if the child search has a better score than beta, and if a best game state has not been decided yet.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/result_bubble_up.png}
            \caption{\texttt{result\_bubble\_up}}
        \end{figure}
        \item \texttt{result\_bubble\_up\_exists\_best} ends and returns the current search, if the child search has a better score than beta, and if a best game state has been decided.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/result_bubble_up_exists_best.png}
            \caption{\texttt{result\_bubble\_up\_exists\_best}}
        \end{figure}
        \item \texttt{result\_discard} discards the result of the child search, as it doesn't have a better score than alpha.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/result_discard.png}
            \caption{\texttt{result\_discard}}
        \end{figure}
    \end{enumerate}
    Furthermore, as the game can either be run between human or machines (or a mix of the two), the \produce\ guard is actually made abstract, and it is inherited by \ai\ and \hproduce\, such that the former can recursively search the tree, and the latter only produce the first depth of the search (to enable selection by the human). And, finally, a \select\ guard is designed, to signal the point of computation in which a move is selected, and the \edgeselect\ edge is added, to represent the decision of either the human or the machine. To enable selection, we have the following two rules:
    \begin{enumerate}
        \item \texttt{select\_ai\_turn}, if the next player is the machine, executes the move, and, appends the \ai\ guard to the stack.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/select_ai_turn.png}
            \caption{\texttt{select\_ai\_turn}}
        \end{figure}
        \item \texttt{select\_human\_turn}, similarly, if the next player is a human, executes the move, and, appends the \hproduce\ guard to the stack.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/select_human_turn.png}
            \caption{\texttt{select\_human\_turn}}
        \end{figure}
    \end{enumerate}

    \paragraph*{How evaluation is done} In traditional chess engines, the evaluation of the board is a complex task, as it requires taking into account a lot of factors, such as the position of the pieces, the pawn structure, the king safety, and more. This is a very complex task, as it requires a lot of heuristics and domain knowledge.
    
    \paragraph{How Bark evaluates} To save computing time, and to make it as simple as possible, in Bark we take into account three factors:
    \begin{itemize}
        \item The material difference between the two players.
        \item The position of the pieces on the board.
        \item The game phase (i.e. the number of pieces on the board).
    \end{itemize}
    We do this by following the \href{https://www.chessprogramming.org/PeSTO%27s_Evaluation_Function}{PeSTO (Piece Square Tables Optimized)} approach, which is a simple heuristic that assigns a value to each piece based on its position on the board and the game phase, which are very important factors in chess.
    To this end, we have defined six \texttt{eval\_*} rules, which are applied when the \evaluate\ guard is present. Except for the piece types, the rules are all the same, and they follow the structure:
    \begin{figure}[H]
        \centering
        \includegraphics[width=.8\linewidth]{images/eval_king.png}
        \caption{\texttt{eval\_king}}
    \end{figure}
    The real difference between the rules is in how they change the attributes of the \evaluate. The original PeSTO evaluation works by using a set of tables, which are used to assign a value to each piece based on its position on the board and the game phase. In Bark, since we can't create arrays, we have rewritten these tables as a simple (and very unwieldy) set of nested ternary operators. As doing such a thing by hand would've been tedious and error-prone, we have written a formatter in Python that takes the values of the tables and outputs the nested ternary operators.

    The resulting evaluation enables us to avoid the need for more complex rules and further computation, which would have been needed to create the value of the board.

    \section{Miscellaneous}
    \paragraph*{Void guard} The \void\ guard is used to block the execution of the stack, until the execution of the layers loops and gets to the \texttt{remove\_void\_guard} rule.
    \begin{figure}[H]
        \centering
        \includegraphics[width=.8\linewidth]{images/remove_void_guard.png}
        \caption{\texttt{remove\_void\_guard}}
    \end{figure}
    \paragraph*{Cleaning} During the recursive search, a lot of \gamestate s are produced, and, when promotion rules are explored, new pieces are created! To avoid the graph becoming too large, we have designed:
    \begin{enumerate}
        \item \texttt{delete\_dangling\_states} which deletes all states that are not referenced by a guard, or by a game state referenced by a guard (\texttt{not\_dangling} and \texttt{is\_being\_processed} NACs), and do not have the \paststate\ edge (designed to keep a record of the game, and enable stuff like en-passant).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/delete_dangling_states.png}
            \caption{\texttt{delete\_dangling\_states}}
        \end{figure}
        \item \texttt{delete\_dangling\_pieces} which deletes all pieces that are not: currently placed, captured, moved at least once, or the result of a promotion (\texttt{is\_placed}, \texttt{was\_captured}, \texttt{moved\_once}, and \texttt{is\_promotion} NACs). Then, the only way that a piece can be removed is if it is the result of a promotion and that game state gets deleted (and therefore \promotioninto\ disappears).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/delete_dangling_pieces.png}
            \caption{\texttt{delete\_dangling\_pieces}}
        \end{figure} 
    \end{enumerate}
    \paragraph*{Tying up the loose "ends"} The last rules that we describe are those which "end" the usage of a guard, and are used to clean up the stack.
    These are placed in a layer greater than the rules of the game, as we exploit the layer functionality and layer looping to discern when the execution of the processes is done.
    The only exception to this is the \texttt{end\_ai\_result} rule, which removes the current \airesult\ guard while on the same layer of the rest of the system, when the next guard in the stack is a \select\ guard (this is done because we don't need the value of the search anymore, as we've exited the search algorithm).
    \begin{figure}[H]
        \centering
        \includegraphics[width=.8\linewidth]{images/end_ai_result.png}
        \caption{\texttt{end\_ai\_result}}
    \end{figure} 
    The rest of the "end" rules are:
    \begin{enumerate}
        \item \texttt{end\_produce} terminates the production of moves when a \hproduce\ guard is present.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_produce.png}
            \caption{\texttt{end\_produce}}
        \end{figure} 
        \item \texttt{end\_produce\_result} terminates the search when an \ai\ guard is present (and returns the result of the search, the \texttt{alpha} attribute), the execution of this rule means that the current search has failed to produce a move with a score higher than the beta!
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_produce_result.png}
            \caption{\texttt{end\_produce\_result}}
        \end{figure} 
        \item \texttt{end\_eval} terminates the evaluation of the board when an \evaluate\ guard is present; to do so it sets the result as the final formula for the PeSTO evaluation.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_eval.png}
            \caption{\texttt{end\_eval}}
        \end{figure} 
        \item \texttt{end\_no\_threats} terminates the threat check, when no threats are found (if the "caller" of the threat check is not a \ai\ guard, for that, we have the next moves).
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_no_threats.png}
            \caption{\texttt{end\_no\_threats}}
        \end{figure}
        \item \texttt{end\_no\_threats\_ai} terminates the threat check, when no threats are found, if the "caller" is the \ai\ guard and \ai's depth is greater than 1. Then further explores by creating a new \ai\ guard referencing the current game state.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_no_threats_ai.png}
            \caption{\texttt{end\_no\_threats\_ai}}
        \end{figure}
        \item \texttt{end\_no\_threats\_eval} terminates the threat check, when no threats are found, if the "caller" is the \ai\ guard and \ai's depth is 1. Then evaluates the board.
        \begin{figure}[H]
            \centering
            \includegraphics[width=.8\linewidth]{images/end_no_threats_eval.png}
            \caption{\texttt{end\_no\_threats\_eval}}
        \end{figure}
    \end{enumerate}

    \section{Conclusions and Limitations}
    The definition of chess and a relative engine for it (which, in spite of the hoops we went through, is still the most simple engine one could define) in an Attributed Graph Grammar is not easy! Both because of how different thinking in terms of graph grammars is and because of how slow the testing of the system went. Indeed, just to run the selection for a single move at a depth of 3 takes roughly an hour on a desktop pc! Because of this, we weren't able to run even a single full game on this system\dots it was just too slow!\\From this, we can assume that either chess is not a good fit for attributed graph grammars, or that AGG, being not designed for heavy processing, is unfit to run such complicated grammars\dots or both (we strongly lean towards this conclusion). Still, this project is probably the first (and last) of its kind, and it may be useful to show the limits of what can be done with graph grammars in general.
\end{document}